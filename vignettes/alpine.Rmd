<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{alpine}
-->

# Modeling and correcting fragment sequence bias

Here we show a brief example of using the *alpine* package to model
bias parameters and then using those parameters to estimate transcript
abundance. The core *alpine* functions will soon be be wrapped into
convenience functions. First, load some small, subset BAM files from
the *airway* package. 

```{r, echo=FALSE} 
library(knitr)
opts_chunk$set(cache=FALSE)
```

```{r, message=FALSE}
library(airway)
library(GenomicAlignments)
library(GenomicFeatures)
```

```{r}
dir <- system.file("extdata", package="airway")
list.files(dir)
bamfiles <- list.files(dir, "bam$", full=TRUE)
names(bamfiles) <- sub("(.*)_subset.bam","\\1",basename(bamfiles))
bamfiles[1]
```

These are reads from a small region.

```{r}
ga <- readGAlignments(bamfiles[1])
range(ranges(ga))
```

To fit the bias model, we need to identify transcripts which belong to
single-isoform genes.

```{r}
gtffile <- file.path(dir,"Homo_sapiens.GRCh37.75_subset.gtf")
txdb <- makeTxDbFromGFF(gtffile, format="gtf", circ_seqs=character())
geneids <- keys(txdb, "GENEID")
txdf <- select(txdb, columns=c("TXNAME","TXID"), keys=geneids, keytype="GENEID")
# normally, we would pick a set of single isoform genes
tab <- table(txdf$GENEID)
single.tx.genes <- names(tab)[tab == 1]
single.txs <- sort(txdf$TXID[txdf$GENEID %in% single.tx.genes])
# this dataset is too small, so we pick one tx per gene (not recommended).
# we will soon update the vignette to use better example data
txs <- sort(sapply(split(txdf$TXID, txdf$GENEID), `[`, 1))
ebt <- exonsBy(txdb, "tx")
ebt <- ebt[txs]
```

These transcripts should have medium to high coverage.

```{r}
so <- summarizeOverlaps(ebt, bamfiles, singleEnd=FALSE)
ebt <- ebt[apply(assay(so),1,min) > 50]
so <- summarizeOverlaps(ebt, bamfiles, singleEnd=FALSE)
assay(so)
```

An example of fitting the bias model. Here, we don't have enough data
to properly fit the model because these BAM files are too small of a subset.
We demonstrate the functions and plan to create a small
demonstration dataset in the meantime. Robust fitting of these bias
parameters is best with ~100 medium to highly expressed genes.

```{r}
library(alpine)
library(BSgenome.Hsapiens.UCSC.hg19)
seqlevelsStyle(Hsapiens) <- "NCBI" # because these BAMs are NCBI-style
genenames <- names(ebt)
names(genenames) <- genenames
# list of fragment types for each single-isoform gene
fragtypes <- lapply(genenames, function(gene) {
               buildFragtypes(ebt[[gene]], genome=Hsapiens,
               readlength=63, minsize=100, maxsize=300)
             })
indexBam(bamfiles[1])
```

The definition of bias models is extremely flexible in *alpine*.
These are defined in a list structure, where each element is a list
with elements `formula` and `offset`. `offset` can be set to `NULL`.
Any kind of R formula is allowed here, which uses information stored
in the elements contained in `fragtypes`. 
The allowable offsets are `fraglen` and/or `vlmm` which
are listed as a character vector. Here we fit a bias model
using fragment length, fragment GC content, and a term for
differences in expression across the genes (`+ gene`).

```{r}
models <- list("GC"=list(formula="count ~ ns(gc,knots=gc.knots,Boundary.knots=gc.bk) + gene",
                         offset=c("fraglen")))
```

Below is an example of full model which is used in the *alpine* paper, but
which we do not fit here. The knots and boundary knots for GC content
and relative position splines are currently fixed internally, and should be
referred to using the following calls:

```{r, eval=FALSE}
  "all" = list(formula = "count ~ ns(gc,knots=gc.knots,Boundary.knots=gc.bk) +
  ns(relpos,knots=relpos.knots,Boundary.knots=relpos.bk) +
  GC40.80 + GC40.90 + GC20.80 + GC20.90 +
  gene",
  offset=c("fraglen","vlmm"))
```

The following command then fits bias parameters one sample at a time:

```{r}
fitpar <- fitBiasModels(genes=ebt,
                            bamfile=bamfiles[1],
                            fragtypes=fragtypes,
                            genome=Hsapiens, models=models,
                            readlength=63, minsize=100, maxsize=300)
fitpar <- list(fitpar) # typically fitpar is a list over samples
names(fitpar) <- names(bamfiles)[1]
```

Visually exploring the bias parameters. These are not robustly fit
in this case because the paucity of reads and genes in the example dataset.

```{r}
plotFragLen(fitpar)
plotGC(fitpar, model="GC")
print(fitpar[[1]]$summary$GC, row.names=FALSE)
```

Estimate transcript abundance, first pick a multiple isoform gene.

```{r}
tab <- table(txdf$GENEID)
mult.tx.genes <- names(tab)[tab > 1]
txs2 <- sort(txdf$TXID[txdf$GENEID %in% mult.tx.genes])
ebt2 <- exonsBy(txdb, "tx")
ebt2 <- ebt2[txs2]
```

For demonstration, pick a gene that has sufficient fragment count.

```{r}
so <- summarizeOverlaps(ebt2, bamfiles[1])
o <- order(assay(so), decreasing=TRUE)[1:3]
txs2 <- rownames(so)[o]
geneids <- txdf$GENEID[txdf$TXID %in% txs2]
```

```{r}
models <- list("null"=list(formula=NULL, offset=NULL),
               "GC"=list(formula="count~ns(gc,knots=gc.knots,Boundary.knots=gc.bk) + 0",
                         offset=c("fraglen")))
```

```{r}
lib.sizes <- 1e6 # any value, this is corrected after counting fragments
names(lib.sizes) <- names(bamfiles)[1]
ebt2 <- exonsBy(txdb, "tx")
# this estimates FPKM for multiple genes and multiple samples
res <- lapply(geneids, function(geneid) {
         txs <- txdf$TXID[txdf$GENEID == geneid]
         ebt <- ebt2[txs]
         estimateTheta(transcripts=ebt, bamfiles=bamfiles[1],
                       fitpar=fitpar, genome=Hsapiens,
                       models=models, readlength=63,
                       minsize=100, maxsize=300,
                       subset=TRUE, niter=100,
                       lib.sizes=lib.sizes)
         })
```

```{r}
res[[1]]
```

These estimates are consistent within sample, but need to be scaled
given the total fragment count and the total bias observed over
genes. The `extract` function does this:

```{r}
mat <- extract(res, model="GC", nsamp=1)
mat
```

```{r}
sessionInfo()
```

.
