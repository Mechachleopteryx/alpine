<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{alpine}
-->

# Modeling and correcting fragment sequence bias

Here we show a brief example of using the *alpine* package to model
bias parameters and then using those parameters to estimate transcript
abundance. We load a subset of reads from four samples from the
GEUVADIS project. For more details on these files, see
`?ERR188297` in the *alpineData* package.

```{r, echo=FALSE} 
library(knitr)
opts_chunk$set(cache=FALSE)
```

```{r}
library(alpineData)
dir <- "~/proj/alpineData/alpineData"
metadata <- read.csv(file.path(dir,"inst/extdata/metadata.csv"),
                     stringsAsFactors=FALSE)
bam.files <- file.path(dir,"inst/scripts/out",
                       paste0(metadata$Title,"_galignpairs.bam"))
names(bam.files) <- metadata$Title
stopifnot(all(file.exists(bam.files)))
```

To fit the bias model, we need to identify single-isoform genes.
We used the following chunk of code (here not
evaluated to generate a *GRangesList* of exons per single-isoform gene.

```{r, eval=FALSE}
library(ensembldb)
gtf.file <- "Homo_sapiens.GRCh38.84.gtf"
txdb <- EnsDb(basename(gtf.file))
txdf <- transcripts(txdb, return.type="DataFrame")
tab <- table(txdf$gene_id)
one.iso.genes <- names(tab)[tab == 1]
# pre-selected genes
selected.genes <- scan("../extdata/selected.genes.txt",what="char")
one.iso.txs <- txdf$tx_id[txdf$gene_id %in% intersect(one.iso.genes, selected.genes)]
ebt0 <- exonsBy(txdb, by="tx")
ebt <- ebt0[one.iso.txs]
save(ebt, file="ebt.rda")
```

Here we pick a subset of single-isoform genes based on the
number of exons, and the length.

```{r}
library(GenomicRanges)
load(file.path(dir,"inst/scripts","ebt.rda"))
# more than 1 exon
table(elementNROWS(ebt))
ebt <- ebt[elementNROWS(ebt) > 1]
# filter small genes and long genes
min.bp <- 1000 # 800 bp
max.bp <- 2000 # 5000 bp
gene.lengths <- sum(width(ebt))
summary(gene.lengths)
ebt <- ebt[gene.lengths > min.bp & gene.lengths < max.bp]
length(ebt)
set.seed(1)
ebt <- ebt[sample(length(ebt),10)] # better 100
```

# Fitting the bias model

Robust fitting of these bias
parameters is best with ~100 medium to highly expressed genes.
It is required to specify a minimum and maximum fragment
size (lower and upper quantiles of the fragment length
distribution) and the read length. Currently
*alpine* only supports unstranded, paired-end RNA-seq with
fixed read length. Differences of +/- 1 bp in read length
across samples can be ignored.

```{r}
library(alpine)
library(BSgenome.Hsapiens.NCBI.GRCh38)
models <- list(
  "all" = list(formula = "count ~
  ns(gc,knots=gc.knots,Boundary.knots=gc.bk) +
  ns(relpos,knots=relpos.knots,Bounday.knots=relpos.bk) +
  GC40.80 + GC40.90 + GC20.80 + GC20.90 +
  gene",
  offset=c("fraglen","vlmm"))
)
minsize <- 100 # better 80 for this data
maxsize <- 250 # better 350 for this data
readlength <- 75 
gene.names <- names(ebt)
names(gene.names) <- gene.names
fragtypes <- lapply(gene.names, function(gene.name) {
                     buildFragtypes(exons=ebt[[gene.name]],
                                    genome=Hsapiens,
                                    readlength=readlength,
                                    minsize=minsize,
                                    maxsize=maxsize)
                   })
```

The definition of bias models is extremely flexible in *alpine*.
The `models` argument should be given as a list,
where each element is model.
The model itself should be provided as a list
with elements `formula` and `offset`. `offset` can be set to `NULL`.
The allowable offsets are `fraglen` and/or `vlmm` which
should be listed as a character vector.

Any kind of R formula can be provided to formula,
making use of the fragment features, `gc`, `relpos`,
`GC40.80`, `GC40.90`, `GC20.80`, `GC20.90`, and `fraglen`,
stored in the elements contained in `fragtypes`.
We recommend providing formula as character vectors,
which are converted internally into formula,
due to details in how R formula make copies of objects
from the environment.

Here we fit a bias model
using fragment length, read start (VLMM),
fragment GC content, GC runs, relative position, and a term for
differences in expression across the genes (`+ gene`).
The knots and boundary knots for GC content
and relative position splines are fixed internally.

```{r}
fitpar <- lapply(bam.files, function(bf) {
                   fitBiasModels(genes=ebt,
                                 bamfile=bf,
                                 fragtypes=fragtypes,
                                 genome=Hsapiens,
                                 models=models,
                                 readlength=readlength,
                                 minsize=minsize,
                                 maxsize=maxsize)
                 })


save(fitpar, file="fitpar.rda")
```

# Visually exploring the bias parameters

```{r}
plotFragLen(fitpar)
```

```{r}
plotGC(fitpar, model="all")
```

```{r}
plotRelPos(fitpar, model="all")
```

```{r}
plotOrder0(fitpar[[1]][["vlmm.fivep"]][["order0"]])
```

```{r}
print(fitpar[[1]]$summary$GC, row.names=FALSE)
```

# Estimating transcript abundances

```{r, eval=FALSE}
models <- list("null"=list(formula=NULL, offset=NULL),
               "GC"=list(formula="count~ns(gc,knots=gc.knots,Boundary.knots=gc.bk) + 0",
                         offset=c("fraglen")))
```

```{r, eval=FALSE}
lib.sizes <- 1e6 # any value, this is corrected after counting fragments
names(lib.sizes) <- names(bamfiles)[1]
ebt2 <- exonsBy(txdb, "tx")
# this estimates FPKM for multiple genes and multiple samples
res <- lapply(geneids, function(geneid) {
         txs <- txdf$TXID[txdf$GENEID == geneid]
         ebt <- ebt2[txs]
         estimateTheta(transcripts=ebt, bamfiles=bamfiles[1],
                       fitpar=fitpar, genome=Hsapiens,
                       models=models, readlength=63,
                       minsize=100, maxsize=300,
                       subset=TRUE, niter=100,
                       lib.sizes=lib.sizes)
         })
```

```{r}
res[[1]]
```

These estimates are consistent within sample, but need to be scaled
given the total fragment count and the total bias observed over
genes. The `extractAlpine` function does this:

```{r, eval=FALSE}
mat <- extractAlpine(res, model="all", nsamp=4)
mat
```

```{r}
sessionInfo()
```

.
